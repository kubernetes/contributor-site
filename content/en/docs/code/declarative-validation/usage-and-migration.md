---
title: "Usage and Migration"
weight: 10
description: |
  How to use Declarative Validation for new APIs and how to migrate existing handwritten validation.
---

This guide explains the Declarative Validation (DV) Lifecycle, how to add validation to new APIs without handwriting Go code, and how to migrate existing handwritten logic to DV tags.

## The Validation Lifecycle

Starting in v1.36, declarative validation rules follow a standard Alpha/Beta/GA lifecycle, controlled by tag prefixes. This allows validations to be safely tested against production data before being fully enforced.

1.  **Alpha (`+k8s:alpha`)**: Shadow mode. The validation runs, and mismatches against handwritten code (or lack thereof) are recorded in metrics, but the request is **not** rejected.
    *   *Syntax*: `+k8s:alpha(since:v1.36)=+k8s:maxLength=100`
2.  **Beta (`+k8s:beta`)**: Enforced by default, but can be disabled via the global `DeclarativeValidationTakeover` feature gate if regressions are found.
    *   *Syntax*: `+k8s:beta(since:v1.37)=+k8s:maxLength=100`
3.  **GA / Standard (No prefix)**: Permanently enforced.
    *   *Syntax*: `+k8s:maxLength=100`

---

## Part 1: Declarative Validation for New APIs

For **New APIs**, we want standard tags to be authoritative from Day 1. This is enabled via a resource-level strategy configuration called `rest.WithDeclarativeEnforcement()`. 

When `WithDeclarativeEnforcement()` is used:
*   Standard tags (e.g., `+k8s:minimum`) become authoritative (Non-Shadowed) and are enforced immediately.
*   Alpha tags remain shadowed.
*   Beta tags are enforced but gated by `DeclarativeValidationTakeover`.

### Walkthrough: New API Validation Usage

### 1. Update API Types (`types.go`)

Add the standard validation tags to your field in `types.go`. Because this is a new API that will use `WithDeclarativeEnforcement()`, standard tags will be enforced immediately.

```go
type PodGroup struct {
    // Name is a unique identifier for the PodGroup within the Workload.
    // +required
    // +k8s:required
    // +k8s:format=k8s-short-name
    Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
    
    // An experimental new field where we want to shadow the validation first.
    // +k8s:alpha(since:v1.36)=+k8s:maximum=100
    Priority int32 `json:"priority" protobuf:"varint,2,opt,name=priority"`
}
```

### 2. Update the Strategy (`strategy.go`)

Ensure your strategy calls the declarative validation runner with the `rest.WithDeclarativeEnforcement()` option. 

```go
func (workloadStrategy) Validate(ctx context.Context, obj runtime.Object) field.ErrorList {
    workloadScheduling := obj.(*scheduling.Workload)
    allErrs := validation.ValidateWorkload(workloadScheduling) // Any cross-field handwritten rules
    
    // Enable Declarative Enforcement to make standard tags authoritative
    return rest.ValidateDeclarativelyWithMigrationChecks(
        ctx, 
        legacyscheme.Scheme, 
        obj, 
        nil, 
        allErrs, 
        operation.Create, 
        rest.WithDeclarativeEnforcement(),
    )
}
```

### 3. Write Associated Tests

When writing tests for your validation logic, errors generated by declarative validation are marked programmatically to reflect their source and stage.

*   Errors from standard tags must be marked with `.MarkNonShadowed()`.
*   Errors from alpha tags must be marked with `.MarkAlpha()`.
*   Errors from beta tags must be marked with `.MarkBeta()`.

```go
"no pod group name": {
    obj: mkWorkload(func(w *scheduling.Workload) {
        w.Spec.PodGroups[0].Name = ""
        w.Spec.PodGroups[0].Priority = 200 // violates alpha maximum
    }),
    expectedErrs: field.ErrorList{
        // Name is a standard tag, so it's Non-Shadowed (authoritative)
        field.Required(field.NewPath("spec", "podGroups").Index(0).Child("name"), "").MarkNonShadowed(),
        // Priority violates an alpha rule, so it's marked as Alpha
        field.Invalid(field.NewPath("spec", "podGroups").Index(0).Child("priority"), 200, "must be less than or equal to 100").MarkAlpha(),
    },
},
```

---

## Part 2: Migrating Handwritten Validation

When migrating existing handwritten validation to the new Declarative Validation system, the goal is strict backward compatibility.

### Prerequisites & Setup

1. **Enable Code Generation**
In `pkg/apis/<group>/<version>/doc.go`, enable the generator if not already enabled:
```go
// +k8s:validation-gen=TypeMeta
// +k8s:validation-gen-input=k8s.io/api/<group>/<version>
package v1
```

2. **Update Strategy**
In `pkg/registry/<group>/<resource>/strategy.go`, modify the `Validate` and `ValidateUpdate` methods to use `ValidateDeclarativelyWithMigrationChecks` (without enforcement!).

```go
func (strategy) Validate(ctx context.Context, obj runtime.Object) field.ErrorList {
    return rest.ValidateDeclarativelyWithMigrationChecks(
        ctx,
        legacyscheme.Scheme,
        obj,
        nil,
        validation.ValidateFoo(obj.(*api.Foo)), // Pass the old validation function errors
        operation.Create,
    )
}
```

3. **Add Equivalence Tests**
Create `declarative_validation_test.go` in the registry directory:

```go
func TestDeclarativeValidation(t *testing.T) {
    apitesting.VerifyValidationEquivalence(t,
        &api.Foo{},
        func(obj runtime.Object) field.ErrorList {
            return strategy.Validate(context.TODO(), obj)
        },
    )
}
```

### Applying Tags and Marking Coverage

1. Add the appropriate tag that matches the handwritten logic to `types.go`.
```go
type LegacyFeatureSpec struct {
    // +k8s:minimum=1
    Replicas *int32 `json:"replicas,omitempty"`
}
```

2. The old handwritten error *must* be explicitly marked as covered by the new tag in `validation.go`. This tells the migration checker "Yes, I know DV handles this now."

```go
if spec.Replicas != nil && *spec.Replicas < 1 {
    // Must append .MarkCoveredByDeclarative()
    allErrs = append(allErrs, field.Invalid(fldPath, *spec.Replicas, "must be greater than or equal to 1").MarkCoveredByDeclarative())
}
```

### Common Pitfalls & Friction Points

#### 1. Short-Circuiting Behavior
Declarative Validation tags like `+k8s:optional`, `+k8s:required`, `+k8s:immutable`, and `+k8s:maxItems` are **short-circuiting**.
*   If a field is missing (and not required), validation stops there.
*   If a field is immutable and changed, validation stops there.

Handwritten code often checks *everything*. You must identify if the handwritten code runs multiple checks that DV would skip. You may need to migrate short-circuiting checks first or replicate the logic.

#### 2. Duplicate Errors
Sometimes handwritten validation accidentally produces duplicate errors. DV will strictly produce one. Fix handwritten code in a separate PR before migrating.

#### 3. Shared Validation Helpers
If a helper function `ValidateCommonSpec` is used by multiple types, refactor it to accept options so that `.MarkCoveredByDeclarative()` is only applied for the specific type you are migrating.

#### 4. Renamed or Moved Fields (Path Normalization)
DV generated code validates the **specific versioned API types** (e.g., `v1beta1` structs), but handwritten validation typically runs against the **internal type**. If a field structure changed between versions, the error paths will differ.
Use **Normalization Rules** in `strategy.go` to map the `v1beta1` path to the internal path before comparison:

```go
var normalizationRules = []field.NormalizationRule{
    {
        Regexp:      regexp.MustCompile(`spec\.devices\.requests\[(\d+)\]\.selectors`),
        Replacement: "spec.devices.requests[$1].exactly.selectors",
    },
}
// Pass via rest.WithNormalizationRules(normalizationRules)
```

---

## 4. Regenerate and Verify

Run the code generator and your tests:

```bash
hack/update-codegen.sh validation
go test ./pkg/registry/<group>/<kind>/...
```
